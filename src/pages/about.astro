---
import { getCollection } from "astro:content";
import { Picture } from "astro:assets";
import { Icon } from "astro-icon/components";
import Layout from "@layouts/Layout.astro";
import Container from "@components/container.astro";
import Sectionhead from "@components/sectionhead.astro";

// Filter team entries with 'draft: false' & date before current date
const publishedTeamMembers = await getCollection("team", ({ data }) => {
  return !data.draft && data.publishDate < new Date();
});

// Sort team members by role hierarchy
const roleOrder = [
  'General Chair',
  'Publication Chair', 
  'Workshop Facilitator',
  'Program Committee'
];

// Separate Program Committee members from others
const programCommitteeMembers = publishedTeamMembers.filter(member => member.data.role === 'Program Committee');
const otherTeamMembers = publishedTeamMembers.filter(member => member.data.role !== 'Program Committee');

const sortedTeamMembers = otherTeamMembers.sort((a, b) => {
  const aIndex = roleOrder.indexOf(a.data.role);
  const bIndex = roleOrder.indexOf(b.data.role);
  
  // If role not found in hierarchy, put at end
  const aOrder = aIndex === -1 ? roleOrder.length : aIndex;
  const bOrder = bIndex === -1 ? roleOrder.length : bIndex;
  
  return aOrder - bOrder;
});

// Function to generate random wiggly path
function generateWigglyPath(seed: string) {
  // Use true random generation for each path
  const random = (min: number, max: number) => {
    return min + (max - min) * Math.random();
  };
  
  const centerX = 200;
  const centerY = 200;
  const baseRadius = 140;
  
  // Create many points for a very smooth curve
  const totalPoints = 8;
  const points: {x: number, y: number}[] = [];
  
  // Generate points with smooth radius variations using multiple sine waves
  for (let i = 0; i < totalPoints; i++) {
    const angle = (i / totalPoints) * 2 * Math.PI;
    
    // Layer multiple sine waves for organic variation
    const wave1 = Math.sin(angle * 3 + random(0, Math.PI * 2)) * random(8, 20);
    const wave2 = Math.sin(angle * 5 + random(0, Math.PI * 2)) * random(5, 12);
    const wave3 = Math.sin(angle * 7 + random(0, Math.PI * 2)) * random(3, 8);
    
    const radiusVariation = wave1 + wave2 + wave3;
    const radius = baseRadius + radiusVariation;
    
    const x = centerX + Math.cos(angle) * radius;
    const y = centerY + Math.sin(angle) * radius;
    
    points.push({ x, y });
  }
  
  // Start the path
  let path = `M ${points[0].x} ${points[0].y}`;
  
  // Create ultra-smooth curves using cubic Bezier curves with better control points
  for (let i = 0; i < totalPoints; i++) {
    const current = points[i];
    const next = points[(i + 1) % totalPoints];
    const prev = points[(i - 1 + totalPoints) % totalPoints];
    const nextNext = points[(i + 2) % totalPoints];
    
    // Calculate smooth control points using catmull-rom spline approach
    const tension = 0.5; // Controls how tight the curves are - increased for smoother curves
    
    // First control point (outgoing from current)
    const cp1Distance = Math.sqrt((next.x - current.x) ** 2 + (next.y - current.y) ** 2) * tension;
    const cp1Angle = Math.atan2(next.y - prev.y, next.x - prev.x);
    const cp1x = current.x + Math.cos(cp1Angle) * cp1Distance;
    const cp1y = current.y + Math.sin(cp1Angle) * cp1Distance;
    
    // Second control point (incoming to next)
    const cp2Distance = Math.sqrt((next.x - current.x) ** 2 + (next.y - current.y) ** 2) * tension;
    const cp2Angle = Math.atan2(nextNext.y - current.y, nextNext.x - current.x);
    const cp2x = next.x - Math.cos(cp2Angle) * cp2Distance;
    const cp2y = next.y - Math.sin(cp2Angle) * cp2Distance;
    
    // Add very subtle organic variation to control points
    const variation1 = random(-2, 2);
    const variation2 = random(-2, 2);
    
    path += ` C ${cp1x + variation1} ${cp1y + variation1}, ${cp2x + variation2} ${cp2y + variation2}, ${next.x} ${next.y}`;
  }
  
  path += " Z";
  return path;
}

// Function to generate wiggly rectangle path for Program Committee boxes
function generateWigglyRectPath(seed: string) {
  // Use seed to create deterministic randomness
  let hash = 0;
  for (let i = 0; i < seed.length; i++) {
    const char = seed.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32bit integer
  }
  
  const random = (min: number, max: number, offset: number = 0) => {
    const x = Math.sin(hash + offset) * 10000;
    return min + (max - min) * (x - Math.floor(x));
  };
  
  // Rectangle dimensions with padding
  const padding = 10;
  const width = 300 - (padding * 2);
  const height = 200 - (padding * 2);
  const x = padding;
  const y = padding;
  
  // Create wiggly points for the rectangle
  const topPoints: {x: number, y: number}[] = [];
  const rightPoints: {x: number, y: number}[] = [];
  const bottomPoints: {x: number, y: number}[] = [];
  const leftPoints: {x: number, y: number}[] = [];
  
  // Top edge
  for (let i = 0; i <= 8; i++) {
    const t = i / 8;
    const wiggle = random(-8, 8, i * 100);
    topPoints.push({
      x: x + (width * t),
      y: y + wiggle
    });
  }
  
  // Right edge  
  for (let i = 1; i <= 7; i++) {
    const t = i / 8;
    const wiggle = random(-8, 8, i * 150);
    rightPoints.push({
      x: x + width + wiggle,
      y: y + (height * t)
    });
  }
  
  // Bottom edge
  for (let i = 7; i >= 0; i--) {
    const t = i / 8;
    const wiggle = random(-8, 8, i * 200);
    bottomPoints.push({
      x: x + (width * t),
      y: y + height + wiggle
    });
  }
  
  // Left edge
  for (let i = 6; i >= 1; i--) {
    const t = i / 8;
    const wiggle = random(-8, 8, i * 250);
    leftPoints.push({
      x: x + wiggle,
      y: y + (height * t)
    });
  }
  
  // Combine all points
  const allPoints = [...topPoints, ...rightPoints, ...bottomPoints, ...leftPoints];
  
  // Create smooth path using quadratic curves
  let path = `M ${allPoints[0].x} ${allPoints[0].y}`;
  
  for (let i = 1; i < allPoints.length; i++) {
    const current = allPoints[i];
    const prev = allPoints[i - 1];
    
    // Control point for smooth curves
    const cpX = prev.x + (current.x - prev.x) * 0.5;
    const cpY = prev.y + (current.y - prev.y) * 0.5;
    
    path += ` Q ${cpX} ${cpY}, ${current.x} ${current.y}`;
  }
  
  path += " Z";
  return path;
}
---

    <div class="mt-16 md:mt-0 fade-in-section p-8 m-4" id="organizers-section">
      <h1 class="text-5xl lg:text-6xl xl:text-7xl text-center font-bold lg:tracking-tight xl:tracking-tighter">
        Workshop Organizers
      </h1>
      <p class="text-lg mt-4 text-slate-600 max-w-xl mx-auto text-center">We are a small passionate team.</p>

        <div class="grid md:grid-cols-3 gap-10 mx-auto max-w-4xl mt-12">
          {sortedTeamMembers.map((teamMemberEntry, index) => {
            const wigglyPath = generateWigglyPath(teamMemberEntry.slug);
            
            return (
              <div class="group">
                <div class="w-full aspect-square relative max-w-[240px] mx-auto">
                  <div class="relative w-full h-full flex items-center justify-center">
                    <Picture
                    src={teamMemberEntry.data.avatar.src}
                    alt={teamMemberEntry.data.avatar.alt}
                    sizes="150px"
                    width={150}
                    height={150}
                    class="w-[150px] h-[150px] rounded-full transition group-hover:-translate-y-1 group-hover:shadow-xl bg-white object-cover object-center aspect-square grayscale group-hover:grayscale-0"
                    />
                    <svg class="absolute inset-0 w-full h-full pointer-events-none" viewBox="0 0 400 400" width="240" height="240">
                    <defs>
                      <clipPath id={`wiggle-clip-${teamMemberEntry.slug}`}>
                        <path d={wigglyPath} fill="white" stroke="none"/>
                      </clipPath>
                    </defs>
                    <path id={`wiggle-path-${teamMemberEntry.slug}`}
                          d={wigglyPath} 
                          fill="none" 
                          stroke="#FF69B4" 
                          stroke-width="12" 
                          stroke-linecap="round"
                          stroke-linejoin="round"
                          class="wiggle-border"/>
                      </svg>
                    </div>
                  </div>

                  <div class="mt-4 text-center">
                      <div class="flex items-center justify-center gap-2 mb-2">
                        <a href={teamMemberEntry.data.homepage} class="text-blue-500 hover:underline"
                        title={teamMemberEntry.data.name}>
                        <h2 class="text-lg text-gray-800 underline">
                        <span class="font-bold">{teamMemberEntry.data.name}</span>
                        </h2>
                        </a>
                        {teamMemberEntry.data.linkedin && (
                          <a href={teamMemberEntry.data.linkedin} target="_blank" rel="noopener" class="text-[#FF69B4] hover:text-[#E055A1] transition-colors">
                            <Icon name="mdi:linkedin" class="w-5 h-5" />
                          </a>
                        )}
                      </div>
                    <h4 class="inline-flex items-center justify-center px-3 py-1 bg-[#FF69B4] text-white text-sm font-semibold rounded-full shadow-md hover:bg-[#E055A1] transition-colors duration-200 mb-2">
                      {teamMemberEntry.data.role}
                    </h4>
                    <h3 class="text-md text-slate-500">
                      {teamMemberEntry.data.affiliation}
                    </h3>
                  </div>
                </div>
            )
          })}
        </div>        <!-- Program Committee Section -->
        <div class="mt-16 p-8 m-4">
          <h2 class="text-4xl lg:text-6xl xl:text-6xl text-center font-bold lg:tracking-tight xl:tracking-tighter mb-8 text-black">
            Program Committee
          </h2>
          <div class="max-w-4xl mx-auto">
            <ul class="grid md:grid-cols-2 lg:grid-cols-3 gap-6 text-center">
              {programCommitteeMembers.map((member, index) => {
                return (
                  <li class="bg-white rounded-lg p-6 hover:bg-gray-50 transition-colors shadow-lg border border-gray-100">
                    <div class="relative inline-block">
                      <div class="flex items-center justify-center gap-2">
                        <a href={member.data.homepage} class="text-gray-800 hover:text-blue-600 text-lg font-bold relative z-10 transition-colors">
                          {member.data.name}
                        </a>
                        {member.data.linkedin && (
                          <a href={member.data.linkedin} target="_blank" rel="noopener" class="text-[#FF69B4] hover:text-[#E055A1] transition-colors relative z-10">
                            <Icon name="mdi:linkedin" class="w-5 h-5" />
                          </a>
                        )}
                      </div>
                      <div class="absolute inset-0 bg-[#FF69B4] opacity-30 -skew-y-3 transform scale-x-125 scale-y-110 rounded-sm"></div>
                    </div>
                    <p class="text-md text-slate-600 mt-4">{member.data.affiliation}</p>
                  </li>
                );
              })}
            </ul>
          </div>
        </div>

        <!-- Reviewers Section -->
        <div class="mt-16 pb-16 p-8 m-4">
          <h2 class="text-4xl lg:text-5xl xl:text-6xl text-center font-bold lg:tracking-tight xl:tracking-tighter mb-4 text-black">
            Reviewers
          </h2>
          <p class="text-lg mt-4 text-slate-600 max-w-2xl mx-auto text-center mb-8">
            We would like to thank our dedicated reviewers for their valuable contributions to maintaining the quality of our workshop submissions.
          </p>
          <div class="max-w-4xl mx-auto text-center">
            <p class="text-lg text-slate-700 italic mb-4">
              Reviewer list will be published after the review process is complete.
            </p>
            <p class="text-md text-slate-600">
              Thank you to all our volunteer reviewers for their time and expertise!
            </p>
          </div>
        </div>
    </div>


<style>
  .fade-in-section {
    opacity: 0;
    transform: translateY(20px);
    transition: opacity 0.6s ease-out, transform 0.6s ease-out;
  }

  .fade-in-section.is-visible {
    opacity: 1;
    transform: translateY(0);
  }

  .wiggle-border {
    animation: wiggle-float 3s ease-in-out infinite;
    transform-origin: center;
    transition: all 2s cubic-bezier(0.4, 0, 0.2, 1);
  }

  @keyframes wiggle-float {
    0%, 100% {
      transform: translateY(0px) rotate(0deg);
    }
    50% {
      transform: translateY(-2px) rotate(0.5deg);
    }
  }

  /* Pause floating animation on hover */
  .group:hover .wiggle-border {
    animation-play-state: paused;
  }
</style>

<script>
  // Function to generate a perfect circle path
  function generateCirclePath() {
    const centerX = 200;
    const centerY = 200;
    const radius = 140;
    return `M ${centerX - radius} ${centerY} 
            A ${radius} ${radius} 0 1 1 ${centerX + radius} ${centerY} 
            A ${radius} ${radius} 0 1 1 ${centerX - radius} ${centerY} Z`;
  }

  // Add hover animations to all team member cards
  document.addEventListener('DOMContentLoaded', function() {
    const teamCards = document.querySelectorAll('.group');
    const circlePath = generateCirclePath();
    
    teamCards.forEach((card) => {
      const wigglePath = card.querySelector('.wiggle-border') as SVGPathElement;
      if (wigglePath) {
        const originalPath = wigglePath.getAttribute('d');
        
        // Mouse enter - morph to circle
        card.addEventListener('mouseenter', () => {
          wigglePath.setAttribute('d', circlePath);
        });
        
        // Mouse leave - morph back to wiggly
        card.addEventListener('mouseleave', () => {
          if (originalPath) {
            wigglePath.setAttribute('d', originalPath);
          }
        });
      }
    });
  });
</script>

<script>
  const observerOptions = {
    threshold: 0.1,
    rootMargin: '0px 0px -50px 0px'
  };

  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        entry.target.classList.add('is-visible');
      }
    });
  }, observerOptions);

  const fadeElements = document.querySelectorAll('.fade-in-section');
  fadeElements.forEach(el => observer.observe(el));
</script>